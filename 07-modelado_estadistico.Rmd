# Modelado estadístico

```{r echo=FALSE, out.width="100%"}
knitr::include_graphics('imagenes/modelado.jpg')

```

Llegamos a un tema de gran interés para quienes realizan investigaciones formales. La posición central que tiene el modelado en la investigación científica se debe a que cuantifica relaciones: permite pasar de decir "La luz solar abundante mejora el crecimiento de las plantas" a "por cada hora adicional de exposición mensual a la luz solar, los cultivos aumentaron su rendimiento en un 1%". La cuantificación permite realizar comparaciones, algo clave para entender un fenómeno estudiado: antes y después, con o sin tratamiento, en un lugar o en otro.

En términos matemáticos, se habla de "modelar" debido a que estamos creando un modelo, una reconstrucción simplificada (¡simplificada en extremo!) de cómo funciona un proceso observado en el mundo real. En un modelo de datos, siempre tenemos al menos

* Una variable resultante, también llamada variable "dependiente", 
* Una o más variables predictoras, también llamadas "explicativas"

El modelado de datos puede ser utilizado para dos propósitos:

1. __Predecir__ el valor de una variable resultante en base a valores conocidos de las variables predictoras. Aquí no interesa tanto entender cómo es que las variables interactúan entre sí, o por qué lo hacen. Mientras las predicciones sean acertadas, o se acerquen lo suficiente, el modelo cumple su cometido. Los modelos predictivos se emplean en una enorme variedad de aplicaciones: inversión en bolsa, prevención de fraude, publicidad online, fijación de primas en seguros de riesgo, etc.

2. __Explicar__ la relación entre una variable dependiente y todas las demás (las explicativas), buscando determinar si la relación es significativa. Los modelos explicativos son los que se favorecen en investigación académica, ya que ayudan a entender el fenómeno modelado.


Existen muchísimas técnicas para modelar datos, algunas de ellas simples como la regresión lineal, y otras mucho más complejas, como las redes neuronales. Vamos a practicar con las primeras. 

La humilde regresión lineal, fácil de explicar y muy fácil de resolver con la ayuda de una computadora, es el caballito de batalla del modelado estadístico. A pesar de que no es adecuada para ciertos tipo de datos, y de que existen métodos más modernos que explotan mucho más el potencial de las computadoras, la regresión lineal sigue siendo una herramienta de uso muy extendido. Un poco por costumbre, y otro porque es el método más fácil de interpretar, lo que favorece entender y comunicar sus resultados.

Este capítulo le debe mucho a _ModernDive: An Introduction to Statistical and Data Sciences via R_ por Chester Ismay y Albert Y. Kim, disponible en forma gratuita en http://moderndive.com/. ModernDive es un recurso muy recomendable para quienes quieran profundizar su conocimiento más allá de los temas que veremos a continuación. Vamos a usar el paquete de R homónimo, `moderndive`, que acompaña al libro y provee funciones que facilitan el aprendizaje de modelos estadísticos.

Antes de continuar, lo instalamos (¡sólo hace falta realizar esto una vez!)

```{r eval=FALSE}
install.packages("moderndive")
```

Y lo activamos:

```{r}
library(moderndive)
```


## Regresión lineal simple

La encarnación más sencilla de la regresión lineal es la simple o univariada. Tenemos nuestra variable $y$, numérica, y una sola variable predictora $x$, que puede ser numérica o categórica.

Para poner en práctica los conceptos repasados en este capítulo, vamos a recurrir a un dataset compilado por [*FiveThirtyEight*](https://fivethirtyeight.com/), un sitio web dedicado al análisis estadístico y periodístico de datos de política, economía y deportes. Sus artículos suelen ser acompañados de los datos originales utilizados para el análisis, lo que permite a la audiencia verificar los hallazgos y realizar sus propias pesquisas. 

El dataset con el que trabajaremos registra la tasa promedio de [crímenes de odio](https://victimconnect.org/tipos-de-delitos/crimenes-de-odio/) reportados en Estados Unidos durante el período 2010-2015, a nivel estado, junto con indicadores demográficos de cada lugar. Los [datos](https://github.com/fivethirtyeight/data/tree/master/hate-crimes) fueron presentados por *FiveThirtyEight* en un [artículo](https://fivethirtyeight.com/features/higher-rates-of-hate-crimes-are-tied-to-income-inequality/) que explora la relación entre desigualdad socioeconómica y crímenes de odio.

Descarguemos entonces el dataset (que hemos traducido pra facilitar su uso), y echemosle un vistazo como ya sabemos hacer:

```{r}
crimenes_odio <- read.csv("https://cdaj.netlify.app/data/crimenes_odio_EEUU.csv")

summary(crimenes_odio)
```

Aclaremos el significado de cada columna:

```{r tabla_vars_hate_crimes, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
Variable | Definición
---|---------
`estado` | Nombre del estado
`mediana_ingreso_hogares` | Mediana del ingreso de hogares (en miles USD), 2016
`pct_desocupados` | Porcentaje de población desocupada, Sept. 2016
`pct_reside_area_metro` | Porcentaje de población que reside en áreas metropolitanas, 2015
`pct_secundaria_completa` | Porcentaje de adultos (25+) con educación secundaria completa, 2009
`pct_no_ciudadanos` | Porcentaje de población sin ciudadanía, 2015
`pct_pobreza_blancos` | Porcentaje de residentes blancos que viven en pobreza, 2015
`indice_gini` | Indice Gini, 2015
`pct_no_blancos` | Porcentaje de población no blanca, 2015
`pct_votantes_trump` | Porcentaje de votantes en las elecciones presidenciales 2016 que votaron por Donald Trump
`crimenes_odio_100k_splc` | Crímenes de odio cada 100.000 habitantes, Southern Poverty Law Center, 2016
`crimenes_odio_prom_100k_fbi` | Promedio anual de crímenes de odio cada 100.000 habitante, FBI, 2010-2015
"
cat(tabl) 
```

Con el poder de `summary()`, comprobar que la incidencia de crímenes de odio varía de forma considerable entre estados. El promedio anual 2010-2015 reportado por el FBI (variable "crimenes_odio_prom_100k_fbi") va de 0,2 a casi 5 incidentes cada 100.000 habitantes. Algo similar ocurre con la cantidad reportada con otra metodología, los datos para 2016 del *Southern Poverty Law Center* ("crimenes_odio_100k_splc"): el rango va de apenas 0,067 incidentes cada 100.000 habitantes hasta 0,83 (¡12 veces más!).


### Regresión con una variable numérica

Hagamos nuestra pregunta pregunta a contestar con una regresión lineal: ¿Cómo ha se relaciona el nivel de ingresos con la incidencia de crímenes de odio?

Como dijimos en el capítulo de visualización, los *scatterplots* son útiles para mostrar la relación entre dos variables. Usemos uno para visualizar la relación entre estas dos variables, para intentar anticipar los resultados de la regresión lineal.

```{r}
# Si no lo hicimos antes, activamos el paquete tidyverse
library(tidyverse)
```

```{r}
ggplot(data = crimenes_odio) + 
    geom_point(aes(x = mediana_ingreso_hogares, y = crimenes_odio_prom_100k_fbi)) +
    labs(title = "Correlación entre ingesos medios por hogar y crímenes de odio",
         subtitle = "Crímenes cada 100.000 habitanes, promedio 2010-2016",
         x = "mediana de ingresos por hogar (miles USD)",
         y = "tasa de crímenes")
```

Los opiniones pueden variar pero aquí parece mostrarse una correlación más bien débil entre las variables, en forma positiva. Esto es, el incremento de una unidad de tiempo en general resulta en el incremento de la expectativa de vida, pero en este caso no de forma drástica. Una correlación _negativa_ sería lo opuesto: que el incremento de la variable explicativa estuviera asociado a un decremento de la variable explicada. Además del _signo_ de una correlación, otra medida importante es su intensidad. La intensidad de una correlación va de -1 (correlación negativa total) a 1 (correlación positiva total). Una correlación de cero significa que las dos variables son por completo independientes. En en ese caso, saber cuánto vale una no nos ayuda a estimar el valor de la otra. 

Para obtener la correlación entre dos variables podemos usar `get_correlation`, una función provista por el paquete `moderndive`. Ponemos el nombre de la variable a explicar en el lado izquierdo del signo "~" (o "tilde"), y ponemos el nombre de la variable explicativa en el lado derecho. Esta forma de escribir la relación entre variables es común en las funciones estadísticas de *R*, y se le llama "notación de fórmula". Por ahora no hay que preocuparse mucho por ella, y ya la encontraremos luego.

```{r}
crimenes_odio %>% 
  get_correlation(formula = crimenes_odio_prom_100k_fbi ~ mediana_ingreso_hogares, na.rm = TRUE)
```
::: warning
Usamos el parámetro `na.rm = TRUE` para descartar las filas donde no contamos con un valor para cualquiera de las dos variables de interés. Nuestro dataset efectivamente tiene algunos valores faltantes (véase otra vez la salida de `summary(crimenes_odio)` para comprobarlo), así que con eso evitamos que la función falle al intentar calcular la correlación.
:::


¿A partir de qué valor consideramos que existe una correlación considerable? La verdad es que no hay una regla a seguir, pero inventemos una. Si el valor absoluto de la correlación es..

    - de 0,7 a 1: de fuerte a total
    - de 0,5 a 0,7: de moderada a fuerte
    - de 0,3 a 0,7: de débil a moderada
    - menor a 0,3: de nula a débil


El valor que obtuvimos no supera por mucho el 0,3; podemos decir que la correlación es débil. Pero aún desconocemos algo quizás más importante: un valor preciso del "efecto" que la variable de ingresos tiene sobre la tasa de crímenes. Eso es lo que vamos a determinar con la regresión lineal. Usamos la palabra "efecto" entre comillas para aclarar una de las limitaciones del modelado estadístico: podemos probar correlación, pero no causalidad. Es decir, no podemos probar que una variable causa a la otra; en todo caso, probamos que se mueven juntas y en base a ello podríamos diseñar un experimento que permita comprobar causalidad.

Vamos a la regresión lineal entonces, para establecer de una buena vez la correlación entre ingresos y crímenes de odio. Usamos la función `lm()` (por "linear model"), así:

```{r}
modelo_ingresos <- lm(crimenes_odio_prom_100k_fbi ~ mediana_ingreso_hogares, data = crimenes_odio)

modelo_ingresos
```

¡Eso es todo! Hemos construido un modelo estadístico; ahora tenemos que aprender a usarlo. Obsérvese que volvió aparecer el simbolillo que denota una fórmula, `~`. Usado como primer argumento de `lm()`, significa "_crimenes_odio_prom_100k_fbi_ vs _mediana_ingreso_hogares_", es decir "estimar el efecto en la variable _crimenes_odio_prom_100k_fbi_ cuando incrementa el valor de _mediana_ingreso_hogares_ ", usando los datos contenidos en el dataframe _crimenes_odio_.

El resultado de `lm()`, que hemos guardado dentro de la variable `modelo_ingresos` es un tipo de objecto con el que no hemos trabajado hasta ahora. No es un dataframe, sino una lista que contiene distintos atributos del modelo estadístico. No hace falta detenernos en eso ahora.

Retomando nuestra pregunta... ¿cuál es el efecto? Lo obtenemos dándole el modelo que generamos a la función `get_regression_table()`, que devuelve una prolija tabla:

```{r}
get_regression_table(modelo_ingresos)
```


Ahí está. En nuestro modelo, el efecto *estimado* de la variable *mediana_ingreso_hogares* es de 0,061. Significado: incrementando en una unidad la variable predictora, la variable a predecir se incrementa en 0.2317. Dicho de otra manera, y expresándolo en las unidades de nuestras variables: por cada mil dólares de incremento en la mediana de ingresos por hogar, la tasa de crímenes de odio cada 100.000 habitantes se incrementa en 0.061 casos.

El otro término que aparece, "intercept" es la _intersección_. Para interpretar el modelo, la intersección rara vez tiene utilidad. Para lo que sí sirve es para trazar la línea que permite "predecir" valores para años en los que no tenemos observaciones. Recordemos la fórmula que define una línea recta:

$$ y = a + b \times x $$

A cada punto en $x$ le corresponde un valor en $y$ que se obtiene multiplicando a $x$ por la _pendiente_, $b$, y sumando la intersección, $a$. Se le llama "intersección" u "ordenada al origen" porque es el valor donde la recta intersecta con el eje de las `y`: cuando $x$ vale $0$, la fórmula nos da $y = b$.


En una regresión lineal, el "modelo" que creamos es precisamente eso: una línea. Tan simple como eso. Lo que la hace tan potente es que la podemos usar como bola de cristal: para saber cuanto valdría la variable dependiente ante un valor determinado de la variable predictora, revisamos por donde pasa la línea.

Lo podemos visualizar con ayuda de `ggplot()`, que por supuesto incluye una función para trazar líneas. Parámetros necesarios: _intercept_ (intersección) y _slope_ (pendiente). Usamos los respectivos valores que nos indica el modelo, `0.412` y `0.033`. 


```{r}
ggplot(data = crimenes_odio) + 
    geom_point(aes(x = mediana_ingreso_hogares, y = crimenes_odio_prom_100k_fbi)) +
    labs(title = "Correlación entre ingesos medios por hogar y crímenes de odio",
         subtitle = "Crímenes cada 100.000 habitanes, promedio 2010-2016",
         x = "mediana de ingresos por hogar (miles USD)",
         y = "tasa de crímenes",
         caption = "con línea de regresión") +
    geom_abline(aes(intercept = 0.412, slope = 0.033), color = "blue")
```

Es hora de dar una definición oficial para una regresión lineal, y es esta: es la línea que describe la ecuación:

$$ \hat{y} = b_0 + b_1 \times x $$
Obsérvese que se trata de la ecuación de una recta, $y = a + b \times x$, con otros nombres. En voz alta, se leería así "Cada predicción del valor de y, llamada $\hat{y}$, se obtiene multiplicando a la variable predictora $x$ por su coeficiente $b_1$ y sumándole el valor de la intersección $b_0$". En otras palabras, a cada valor de $x$ (las observaciones de la variable explicativa) le corresponde un punto en la recta trazada por el modelo. La altura sobre la recta de las $y$ para ese punto es el valor predicho para la variable dependiente. Por ejemplo, si quisiéramos estimar la 

Ya que estamos, aprendamos otro truco. `ggplot()` puede agregar a nuestros scatterplots una capa con la línea de la regresión lineal, en forma automática. La función `geom_smooth()` se usar para explicitar patrones en los datos. Tal como otras de la familia ggplot, espera que se le diga que variables asignar a `x` e `y`, más un parámetro `method` con el método solicitado para trazar una línea de tendencia. Aquí usamos `method = "lm"` por _linear model_, el modelo lineal.

```{r}
ggplot(data = crimenes_odio) + 
    geom_point(aes(x = mediana_ingreso_hogares, y = crimenes_odio_prom_100k_fbi)) +
    labs(title = "Correlación entre ingesos medios por hogar y crímenes de odio",
         subtitle = "Crímenes cada 100.000 habitanes, promedio 2010-2016",
         x = "mediana de ingresos por hogar (miles USD)",
         y = "tasa de crímenes",
         caption = "con línea de regresión vía geom_smooth()") +
    geom_smooth(aes(x = mediana_ingreso_hogares, y = crimenes_odio_prom_100k_fbi), method = "lm")
```

Hacer una regresión lineal se trata de encontrar la línea que atraviesa nuestra nube de puntos de modo tal que la suma de las distancias de cada punto a la línea sea la menor posible. Es un problema matemático que puede resolverse con distintas técnicas (álgebra lineal, geometría, etc) que no vamos a discutir aquí. Confiaremos en R para hacer los cálculos.  

En la relación ingresos - crímenes las distancias entre los puntos (las observaciones) y la línea (el modelo) varían bastante entre casos. Eso indica que el modelo no describe con gran precisión la dinámica de la relación entre las variables analizadas.

En general, es inusual encontrar una correlación nítida entre variables "en la vida real", sobre todo cuando estudiamos procesos complejos cuyo comportamiento describe patrones más complejos que una relación lineal pura. 

¿Debería preocuparnos eso? No siempre. A veces la regresión sirve más para cuantificar la relación entre dos variables, en sentido general, y no para realizar certeras predicciones o caracterizar de forma exacta un fenómeno con solo disponer de una variable explicativa. Si nos conformamos con eso, lo importante es que nuestro modelo sea "justo", proveyendo un estimado con errores mas o menos parejos. Es decir, sin observaciones puntuales para las que el modelo resulta mucho peor que para otras.

Una parte importante del análisis basado en regresiones es revisar estos errores -la distancia entre el valor predicho y la observación-, y decidir si ameritan buscar una explicación. Para ello, lo mejor es empezar por prestar atención a los residuos.

### Revolviendo los residuos

Los residuos, en la jerga estadística, no son otra cosa que las diferencias encontradas entre el valor que predice un modelo para una variable y el valor observado en la práctica. Es decir, el valor para cada punto de $y - \widehat{y}$. Los residuos representan el desvío de cada observación respecto al valor "esperado" por el modelo.

Cuando los desvíos son pequeños, es decir cuando los residuos son pequeños, decimos que nuestro modelo se ajusta bien a los datos observados. Cuando los residuos son grandes ocurre lo contrario, y quizás deberíamos buscar otra forma de describir -de modelar-, la relación entre las variables.

Prestemos atención a los residuos de nuestro modelo. Podemos extraer los residuos (y algunas cosillas más!) usando la función `get_regression_points()`,

```{r}
resultados_regresion <- get_regression_points(modelo_ingresos)
resultados_regresion
```

Obtenemos los resultados del modelo para cada observación, o sea cada fila de nuestro dataframe original.
La columna que buscamos está al final (`residual`). También tenemos

* `crimenes_odio_prom_100k_fbi`: El valor observado en los datos que usamos para el modelo, para la variable que intentamos predecir; es el valor de $y$
* `mediana_ingreso_hogares`: El valor que toma la variable predictora, alias $x$ 
* `crimenes_odio_prom_100k_fbi_hat`: Este es el valor que "predice" el modelo, alias "y con sombrerito" (de ahí lo de _hat_), o $\hat{y}$ 
* `residual`: y por fin los residuos, la diferencia $y - \hat{y}$ para cada fila.


Podemos notar que en algunos casos el error / residuo / desvío es bastante grande, en relación a la magnitud de la variable a predecir. Esto era esperable dada la débil correlación entre variables.

Siempre podemos esperar una cierta divergencia entre las predicciones y los valores observados, por lo que los residuos siempre tendrán (en general) un valor distinto a cero. Pero es importante que los residuos se distribuyan al azar, sin indicios de _patrones sistemáticos_. Si así fuere, podemos considerar que nuestro modelo es adecuado. 

¿Cómo determinamos que no exhiben patrones sistemáticos? Una vez mas, se trata de una evaluación bastante subjetiva, y cada quien estará conforme dependiendo del contexto y la experiencia previa. Aún así podemos argumentar en favor de la adecuación del modelo cuando:

1. El promedio de los residuos se aproxima a cero; es decir, que los residuos positivos se cancelan con los negativos, promediando cerca de cero.
2. El valor de los residuos no depende del valor de $x$; es decir, no se observa un crecimiento (o decrecimiento) sistemático de la magnitud de los residuos a medida que$x$ crece


Veamos si nuestro modelo cumple con `1.`, calculando el promedio de los residuos:

```{r}
mean(resultados_regresion$residual)
```

Dio un resultado infinitesimal, cercano a 0, así que condición cumplida.


¿Y que pasa con `2`, la magnitud de los residuos sin crecer ni decrecer de forma notable a medida que se incrementa la variable predictora? Veamoslo en un gráfico de dispersión:

```{r}
ggplot(resultados_regresion) +
    geom_point(aes(x = mediana_ingreso_hogares, y = residual)) +
    labs(x = "Mediana del ingreso de hogares", y = "residuo del modelo lineal")
```

No se ve una "rampa" ascendente o descendente de los residuos a medida que aumenta la variable de ingresos, así que condición cumplida.


### Regresión con una variable categórica

El dataset de crímenes de odio no incluye variables categóricas además de la de estado. Pero podemos crearnos una con facilidad: "¿Ganó Donald Trump en las elecciones presidenciales de 2016?". Para sumar esta variable podemos usar `mutate()` para sumar una columna, y como contenido asignarle el resultado de evaluar si Trump obtuvo al menos el 47% de los votos. Es un umbral de corte definido revisando los [resultados](https://www.nytimes.com/elections/2016/results/president) de aquella elección, nada riguroso pero servirá para practicar ahora:


```{r}
crimenes_odio <- crimenes_odio %>% 
  mutate("trump_electo" = pct_votantes_trump > 0.46)
```

Esto nos da una columna `trump_electo` de tipo "logical". Es decir que contiene "cierto" o "falso" (`TRUE` o `FALSE`). Una variable dicotómica, que cae dentro del tipo categórico.

Comencemos por explorar los datos con una visualización.

```{r}
ggplot(data = crimenes_odio) +
    geom_point(aes(x = trump_electo, 
                   y = crimenes_odio_prom_100k_fbi, 
                   color = trump_electo)) 
```

Se vislumbra que una menor tasa de crímenes de odio parece estar asociada a los estados donde Trump ganó la elección en 2016. Eso si, la profusión de puntos hace que muchos terminen superpuestos, haciendo imposible determinar cuántos ocupan cada posición (un problema llamado _overplotting_ en inglés). Una variante de `geom_point()` llamada `geom_jitter()` resuelve este problema al "sacudir" los puntos, sumando a cada uno un pequeño valor al azar para que se separe de los que comparten su posición. Es un buen ejemplo de la paradoja por la cual reducir la precisión de la información a veces permite entender mejor lo que está ocurriendo. Usamos `geom_jitter()` igual que `geom_point()`:

```{r}
ggplot(data = crimenes_odio) +
    geom_jitter(aes(x = trump_electo, 
                   y = crimenes_odio_prom_100k_fbi, 
                   color = trump_electo)) 
```

Algún ojo avizor habrá notado que la clasificación por color no es necesaria, ya que el resultado de la elección está señalado por la posición en el eje de las `x`. El color cumple aquí una función más que nada cosmética, en pos de hacer al gráfico maś atractivo a la vista.

Otra forma de visualizar la diferencia es con un histograma facetado por la variable "trump_electo":

```{r}
ggplot(crimenes_odio) +
  geom_histogram(aes(crimenes_odio_prom_100k_fbi, fill = trump_electo)) +
  facet_wrap(~ trump_electo)
```



Bien, parece haber una relación entre resultados electorales y crímenes de odio, aunque no la hemos cuantificado. Para eso, recurrimos a una regresión lineal con variable explicativa categórica. Se obtiene de la misma manera que antes, no hay cambios en la forma de invocar `lm()` por el hecho de que la variable ahora sea categórica en vez de numérica.


```{r}
modelo_eleccion <- lm(crimenes_odio_prom_100k_fbi ~ trump_electo, data = crimenes_odio)

modelo_eleccion
```

¿Qué ocurrió aquí? `lm()` inspeccionó el contenido de la variable "continente" y encontró cinco niveles o categorías. Tomó el primero en orden alfabético, "Africa", como línea de base. El primer coeficiente de la regresión (la intersección) es el promedio de la expectativa de vida en África. Para cada una de las categorías restantes, el coeficiente representa la diferencia respecto a África de la expectativa de vida promedio en cada uno de los otros continentes. He allí la cuantificación: para un país en las Américas, podemos esperar -en promedio- una expectativa de vida que supera en 18.8 años la de los países africanos. Para un país en Asia, son 15.92 los años adicionales, y así.

Prestemos atención a los residuos. Agregamos al dataframe una columna con el residuo para cada observación,

```{r}

data_mundial_2007 <- data_mundial_2007 %>% 
    mutate(residuo_ml = residuals(modelo_exp_continente))
```

y graficamos la dispersión de los residuos en torno a cero, el valor ideal:

```{r}
ggplot(data_mundial_2007) +
    geom_jitter(aes(x = continente, y = residuo_ml), width = 0.1) +
    geom_hline(yintercept = 0, col = "blue") +
    labs(x = "año", y = "residuo del modelo lineal")
```

Notamos que:

1. Los residuos están repartidos en forma pareja entre positivos y negativos. Eso indica que su promedio será cercano a cero, lo cual es bueno.
2. En Asia hay un país cuyo valor observado está muy por debajo del esperado por el modelo. Se separa tanto de los demás que debemos considerarlo un _outlier_, un valor tan inusual que amerita ser revisado.
    
Con la magia de los verbos de transformación que sabemos, aislemos a los países en Asia con menor expectativa de vida para identificar al _outlier_.
    
```{r}
data_mundial_2007 %>% 
    filter(continente == "Asia") %>% 
    arrange(expVida) %>% 
    head()
```

    
Se trata de Afganistán. Como explicación, uno piensa de inmediato en las largas guerras libradas en ese territorio, y en particular la invasión por parte de los Estados Unidos en 2001 -¡otra vez ese año!-. Podemos verificarlo con un gráfico que muestre la evolución de la expectativa de vida según los años.

```{r}

data_afganistan <- data_mundial %>% filter(pais == "Afghanistan")

ggplot(data_afganistan) + 
    geom_line(aes(x = anio, y = expVida)) +
    labs(title = "Expectativa de vida en Afganistán",
         y = "expectativa de vida")
```

Vaya sorpresa. A pesar de ser en extremo baja comparada con el resto de Asia, la expectativa de vida en Afganistán en el 2007 es la más alta de la historia, y no sólo eso: ha aumentado con rapidez _después_ del año de la invasión. ¿A qué podemos atribuir entonces la bajísima expectativa de vida? Teniendo en cuenta que el país ha sufrido conflictos bélicos en forma continua desde fines de los '70, podría tratarse de una tragedia histórica: los años que faltan son los que el país habría alcanzado si las guerras no hubieran alterado su ritmo de progreso. 

Dependiendo del esfuerzo que requiera determinar la causa de un _outlier_, una alternativa razonable es dejarlo de lado. Es un poco cruel, pero realista: cuando tenemos cientos, miles o millones de observaciones, hacer una "poda" de los valores extremos que nuestros modelos no pueden explicar termina siendo la opción más razonable. Dedicar recursos limitados a la caza de una explicación o a complejizar el modelo agregando variables hasta lograr predecir los _outliers_ no tiene sentido cuando se trata de casos aislados y fortuitos. Por otra parte, eliminarlos antes de tiempo podría hacernos ignorar los casos más interesantes de un dataset, los que más información podrían revelar. Existen tratados completos dedicados a la cuestión de como manejar los _outliers_, pero el conocimiento de dominio es la principal herramienta para decidir que hacer ante casos inusuales... como siempre. 


## Regresión con múltiples variables

Hasta aquí hemos usado la regresión lineal para hacer explícita la relación entre una variable _resultante_ $y$ y una única variable _predictiva_ o _explicativa_ $x$. En algunos de nuestros resultados pudimos intuir que el agregado de alguna variable explicativa adicional podría mejorar nuestras predicciones. De eso se trata la regresión lineal múltiple: incorporar una cantidad arbitraria de variables al modelo, buscando representar las múltiples dinámicas que inciden en el fenómeno estudiado.

Una buena noticia es que, en general, agregar variables a nuestro modelo estadístico no requiere mucho esfuerzo adicional. En la época en que los cálculos matemáticos debían hacerse sin la ayuda de una computadora, sumar variables sin ton ni son debía tener poca gracia, debido a la creciente cantidad de cálculos a resolver. Para nosotros que dejamos la tarea en manos de software especializado, el problema es el opuesto. Es tan fácil sumar variables al modelo, que debemos evitar la tentación de arrojar todo dentro de la fórmula de regresión lineal y decidir luego que parece importante y que no. 

Pasemos a la práctica. Vamos a modelar la expectativa como resultante de la población y del PBI per cápita de los países, usando los datos más reciente (tomados en 2007). La única diferencia respecto a una regresión lineal simple es que usamos `+` para agregar variables en la fórmula de `lm()`


```{r}
modelo_exp_multiple <- lm(expVida ~ pobl + PBI_PC, data = data_mundial_2007)

modelo_exp_multiple

```

¿Cómo interpretamos esos resultados? Más o menos de la misma manera que con la regresión simple. Como antes, tenemos un coeficiente para la intersección, al que no prestamos mucha atención porque no nos dice nada de la relación entre las variables. Lo que cambia es que esta vez tenemos dos variables predictoras en lugar a una, cada una con su coeficiente. Los coeficientes positivos indican que la relación de la población con la expectativa de vida es de correlación positiva (cuando una crece la otra tiende a crecer también), y lo mismo ocurre con el PBI. La magnitud de los coeficientes es pequeña (minúscula en el caso de la población), lo cual dificulta "narrar" los resultados, pero podemos hacerlo así:
    
* Cuando las demás variables se mantienen constantes (es decir, en países con PBI similar) el incremento de una unidad de población -un habitante- está asociado a un incremento de 0,000000007 años en la expectativa de vida del país... unas dos décimas de segundo.
* Cuando las demás variables se mantienen constantes (es decir, en países con población similar) el incremento de una unidad de PBI -un dólar per cápita- está asociado a un incremento de 0,00064 años en la expectativa de vida del país... un poco más de cinco horas y media.
    
Pensemos un poco si los resultados tienen sentido. La correlación positiva entre PBI y longevidad es de lo más razonable. No nos extraña que los países de mayores ingresos tiendan a ser aquellos cuyos habitantes viven más tiempo. La correlación con la población es quizás inesperada. Si la longevidad se incrementa junto a la cantidad de habitantes, ¿acaso no deberíamos encontrar a varios de los países más populosos entre los más longevos?

Veamos el _top ten_ de países más poblados:

```{r}
data_mundial_2007 %>% 
    arrange(desc(expVida)) %>% 
    head(n = 10)
```

y el de países con mayor expectativa de vida:

```{r}
data_mundial_2007 %>% 
    arrange(desc(pobl)) %>% 
    head(n = 10)
```

El único país presente en ambas listas es Japón. Ni nuestro conocimiento del mundo, ni los datos parecen apoyar la noción de que población y longevidad van juntos. Ya hemos usado `cor()` para obtener una medida de la intensidad de la correlación entre dos variables. Veamos que pasa con longevidad vs. población:

```{r}
cor(data_mundial_2007$expVida, data_mundial_2007$pobl)
```

Recordemos que la intensidad de una correlación es su valor absoluto, que toma un máximo de 1, mientras que el signo (positivo o negativo) indica si la relación entre variables es directa o inversa. Aquí obtuvimos un valor bien bajo, cercano a cero: la correlación es nula. Entonces ¿Por qué aparece en nuestro modelo de regresión lineal?

En resumidas cuentas, aparece porque nosotros le pedimos que aparezca. Es decir, instruimos en forma específica a `lm()` para que incorpore a la población en el modelo. El caso es que población no es un buen predictor de longevidad (la correlación es bajísima), pero si lo pedimos, lo tenemos: el coeficiente nos indica el valor que minimiza las discrepancias entre valores observado y valores predichos trazando una línea recta. Lo que no indica por si solo es el grado en el cual podemos confiar en esa variable para darnos buenas predicciones o estimados.

Sería muy útil que el resultado de `lm()` indique cuáles variables son buenas predictoras y cuáles no. Y por suerte, lo hace cuando lo interrogamos con `summary()`, la misma función que hemos estado usando para obtener el resumen de un dataframe. Cuando la usamos con un objeto de R que contiene un modelo estadístico, lo que obtenemos son sus detalles:   

```{r}
summary(modelo_exp_multiple)
```

El resumen incluye los parámetros que definieron al modelo, los valores por cuartil de los residuos, y una tabla con variables numéricas. En esa tabla, bajo la columna `Estimate` tenemos el "efecto" estimado de cada variable explicativa sobre la dependiente. Es decir, los coeficientes que ya conocemos. Luego aparecen tres columnas con atributos estadísticos: `Std. Error`, `t value`, y `Pr(>|t|)`. En castellano las llamaríamos, respectivamente, _error estándar_, _valor t_ y _valor p_. Interpretar estos valores cae fuera de nuestros objetivos, pero podemos señalar que el más famoso entre ellos es el _valor p_, porque se usa como medida: si vale menos de 0,5, se considera que la capacidad de predicción de la variable asociada es significativa. Para interpretar todo esto de manera sencilla, una vez más vamos a confiar en R para guiarnos. He aquí la curiosa forma de determinar si una variable es buena predictora o no: contar estrellitas. Junto a cada fila aparecen, a veces, de uno a tres asteriscos. Son la forma de R de decirnos cuales son las variables explicativas que muestran una relación "estadísticamente significativa" con nuestra variable dependiente. Cuanto más bajo el valor p, más significativa es la relación y más estrellitas aparecen:


- `.` o nada: No se encuentra una relación entre esta variable y la que queremos predecir.
- `*`: Es muy probable que esta variable tenga una relación con la que queremos predecir. Ya podemos publicar estos resultados en un paper científico.
- `**`: Es muy, pero muy probable que esta variable tenga una relación con la que queremos predecir. 99% seguro.
- `***`: Juramos que las variables están relacionadas. Más no se puede pedir.

Lo de un asterisco/estrella (`*`) indicando que los resultados ya alcanzan rigor científico no es broma. El asterisco solitario indica que, a nivel estadístico, se supera el 95% de confianza en que la relación existe en la realidad y no es producto de una casualidad en los datos. Pasando ese umbral se considera que los datos son "estadísticamente significativos", y desde hace muchos años encontrar un _valor p_ menor a 0,05 es la meta dorada de los investigadores que emplean análisis estadístico. ¿Porqué un 95% de confianza alcanza? ¿Porqué no relajar el límite a 90%, o quizás mejor, exigir al menos un 99 o 99,9% de seguridad? La verdad es que no hay ninguna razón trascendental. El 95% de certeza es tan sólo un umbral arbitrario que en algún momento se volvió estándar. Es importante aclarar que en los últimos años ha crecido una reacción de rechazo a esta norma arbitraria, dentro de la propia comunidad científica. Quienes siguen confiando en los _valores p_ son llamados "frecuentistas"; los que proponen cuantificar de otra forma nuestro grado de certeza son llamados "bayesianos". Google mediante, quien quiera saber más sobre la apasionante rivalidad tendrá horas de diversión aseguradas.

En lo que a nosotros respecta, por ahora vamos a aceptar el enfoque frecuentista, y cuando veamos una estrella diremos que la variable asociada es un buen predictor. O para ser más precisos, que su relación con la variable dependiente es estadísticamente significativa.


Volvamos a nuestros modelos. Cuando hicimos regresiones simples no sabíamos aún de valores p, y no revisamos la significancia de las variables predictoras. Hagámoslo ahora con el modelo de expectativa de vida en Argentina vs. PBI :


```{r}
summary(modelo_exp)
```

Las tres estrellitas, distinción máxima, indican que sin dudas el año está relacionado con la expectativa de vida. Esto no es una sorpresa: la linea de la regresión lineal se ajusta con tanta precisión a los valores observados, que no podía ser de otra manera.


Continuando con las regresiones múltiples, intentemos un modelo con tres variables predictoras. A población y PBI, las que ya teníamos en cuenta, vamos a agregar una variable categórica: el continente. 

```{r}
modelo_exp_multiple <- lm(expVida ~ pobl + PBI_PC + continente, data = data_mundial_2007)

summary(modelo_exp_multiple)
```

Observamos que la variable categórica es significativa. Con las demás variables fijas -es decir, en países de similar PBI y población- el continente de origen explica en gran medida las diferencias en expectativa de vida en cada país, y con un efecto estimado enorme - ¡de 12 a 16 años!-. Notemos de todos modos que el coeficiente de la variable continente había sido mayor en el modelo simple, llegando a casi 26 años para Oceanía. ¿Porqué es menor ahora? Porque nuestro modelo es más completo, y tiene en cuenta más variables. Cuando lo único que teníamos para comparar países era su continente, era era la única variable a la que atribuir diferencias. Ahora que consideramos múltiples variables para explicar las diferencias, notamos la parte de la influencia que se lleva el PBI, reduciendo la del continente.


## Ejercicios

I. En base a un dataset de nuestra preferencia, mostremos la relación entre dos variables continuas o numéricas usando un gráfico de dispersión (geom_point). Expliquemos lo que muestra el gráfico.

II. Realicemos un modelo de regresión lineal para esas dos variables. Describamos los resultados, ofreciendo una interpretación.

III. Mostremos la relación entre una variables categórica y otra continua/numérica, con un gráfico _boxplot_ (mediante `geom_boxplot()`) o un gráfico de puntos "sacudidos" (mediante `geom_jitter()`). Expliquemos lo que muestra el gráfico.

IV. Realicemos un modelo de regresión lineal para esas dos variables, describiendo los resultados sin olvidar interpretarlos.

V. Realicemos una regresión lineal con la variable a predecir de 5.1  o 5.3, con la misma variable predictora ya utilizada junto con otras adicionales. Es decir, realizar una regresión con múltiples variables predictoras.  Describamos los resultados, interpretándolos. ¿En qué cambian respecto al modelo que usa sólo un predictor?


---

Con eso cerramos el capítulo, y el manual.

Esperamos haber provisto una introducción satisfactoria al análisis, modelado y visualización de información, y que haya sido tan sólo el inicio de un largo y gratificante recorrido.

¡Gracias por haber llegado hasta aquí! 
